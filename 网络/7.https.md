### 安全通信的 4 个特性

- 机密性，保证除了通信双方，对其他人不可用

- 完整性，传输过程中，数据没有被篡改

- 身份验证，确保通信对方是真实可靠的，是我想要通信的

- 不可否认

### 加密方式/模型

- 首先明确一点，理论上，几乎所有的加密方式都是可破解的，因为，目前密码研究关心的时**在计算上不可破解**，即 “即使一个密码可被破解，但不能在一定时间内被破解，那么他在计算上就是安全的”，比如破解密码需要一台计算机连续计算 1000 年，算不算安全

- 对称加密体制：加密秘钥 和 解密秘钥，使用相同的密码

  解决的问题：保密性
  优点：计算量较小
  缺点：1. 通信前要约定好秘钥，或先传输秘钥，而这个传输过程又有可能被拦截，监听等；2. 与 n 个端通信，需要维护 n 个秘钥，每条信道都是唯一的

- 公钥密码体制：维护一对秘钥（公钥 PK，私钥 SK），使用不同的秘钥进行加密和解密。

  现在有 B 的一对秘钥 PK_B - SK_B，A 要给 B 发送信息 mess，首先使用 B 对外公开的公钥对内容加密，得到了密文 PK_B(mess)，B 收到密文后，使用自己的 SK_B 即可解密出正确的内容，由于黑客没有 SK_B，所以即使截获了密文，也不能解密出报文内容。注意使用 PK 加密，然后用 SK 解密，和使用 SK 加密，然后用 PK 解密，得到的结果是一样的，即 PK(SK(mess)) === SK(PK(mess))，这个属于数学问题，这里就不深入了

  解决的问题：数字签名，秘钥分配（上面提到的传输秘钥）
  优点：安全
  缺点：1. 计算量大；2. 公钥信任问题，中间人攻击

### 电子签名

- 签名的基本原理是，A 使用自己的秘钥 SK(A) 加密签名信息，网络上任何持有公钥 PK(A) 的人，都可以解密得到正确的签名信息，由于黑客没有 SK(A)，针对同一个签名信息，不能得到相同的伪造密文，若使用自己的 SK 加密一段伪造签名，又不能被 PK(A) 正确的解密还原出来。

- 注意这个过程中签名内容可以被任何持有 PK(A) 的人还原出来，报文本身并不具有保密性，这时可以通过下面的方式来解决：

  A 端，有自己的私钥 SK_A，对外公开的公钥 PK_A

  B 端，有自己的私钥 SK_B，对外公开的公钥 PK_B

  A 要发送数字签名 sign_A, 先使用 SK_A 加密，得到一个不可篡改的签名密文，再使用 PK_B 得到一个新的密文保证只有 B 可以解密还原他得内容

  加密报文到达 B，首先用 SK_B 解密（因为报文最后一次加密使用 PK_B），解密得到的密文，再使用 PK_A 解密（签名流程），就可以原始签名内容了

### 鉴别（完整性）

- 其实使用电子签名的方式就可以对报文完整性进行鉴别，但由于公钥密码体制的计算量很大，对于比较长的报文进行电子签名，会有很大的计算负担，所以就衍生出了 **摘要算法**

- 摘要，就是把一段任意长度的数据，压缩成固定唱的的摘要内容，且这个操作是单向不可逆的。针对一段报文，我们只需要计算它的摘要内容，并对摘要进行电子签名即可，因为摘要长度固定且长度较短，所以不会消耗太多的计算资源

- 注意一点，**鉴别** 的目的是保证数据完整性，对于传输的报文内容是不进行加密的，一般的鉴别流程是：
  1. A 要发送报文 X，首先通过报文 X，计算出摘要 H
  2. 对 H 进行电子签名（自己私钥），得到 **报文鉴别码**
  3. 把 报文鉴别码 拼接在报文 X 后面
  4. 报文到达 B 后，先拆分出报文体和报文鉴别码
  5. 对报文进行摘要运算，得到 H2，然后对报文鉴别码进行 电子签名解密（A 的公钥），得到的值和 H2 进行比对，如果一样，说明报文完整

### 链路

1. 首先是加密问题，两种加密算法很好的解决了这个问题
2. 其次是身份问题，电子签名很好的解决了这个问题，证明了 “我就是我” 的问题
3. 然后，针对完成性问题，又要兼顾运算资源，得到了 摘要/鉴别 的方法
4. 最后，因为公钥的信任问题，引入了 CA 机构，证明了 “你就是你” 的问题

---

### https 是什么

- 普通的 http 协议属于应用层协议，是直接和下层的 tcp/ip 协议进行交互的，但是 tcp 协议不能保证安全性

- https 协议是在 应用层的 http 协议 和 传输层的 tcp 协议之间，添加了一层 SSL/TLS 协议，用于安全校验

- SSL/TLS 协议被划分到 应用层，和 http 一起，组成了 **https 协议**

- https 本身基本沿用了所有 http 特性，只是替换了底层协议

### CA

- 这里说一下 CA 证书，若 CA 中心要给 A 颁发证书，那么首先要拿到 A 的公钥 PK_A，然后 CA 中心会使用自己的私钥 SK_CA 对 PK_A 等一些信息进行电子签名，得到 A 的电子证书。当有人想校验这个证书是不是属于 A 时，就把从 A 得到的证书，用 CA 中心的公钥 PK_CA 进行解密，得到的值如果是 A 相关的，说明证书无误

### SSL/TLS 的连接过程

由于 SSL/TLS 下层协议是 TCP/IP，所以想进行安全通信，首先要建立 tcp 连接，（下面 A 是 浏览器，B 是服务器）

1. 3 报文握手，建立 tcp 连接

2. A 向 B 发送 SSL 版本号和一些 A 支持的加密套件（加密算法等）

3. B 收到报文后，选择一个加密算法（如 RSA），并告知 A
4. B 向 A 发送包含 RSA 公钥的数字证书

5. A 使用该证书的认证机构 CA 公开发布的公钥对该证书进行验证
6. 验证通过，A 产生一个随机数，用 B 的 RSA 公钥进行加密，发给 B
7. B 通过 RSA 私钥，解密得到 这个随机数，这时，A,B 都持有了这个随机数
8. 双方通过 RSA 加 random，得到一个回话秘钥

9. 之后的通信就使用对称密码体制，秘钥就是这个会话秘钥
