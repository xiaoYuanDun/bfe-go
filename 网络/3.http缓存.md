### http 优化(缓存,压缩)

### micor/http-server

##### cache-control

注意, 首次访问的地址不会走缓存

res.setHeader('Cache-Control', 'max-age=10')
此时间表示相对于访问服务器起的相对时间, 10S 内不在向服务器发起请求

res.setHeader('Expires', '...')
老版本使用, 参数是绝对时间, 需要手动计算

no-cache, 配合协商缓存
浏览器每次都会缓存文件, 但是每次请求都会发往服务器

no-store
浏览器不会缓存文件, 且每次请求都会发往服务器

### 对于不常更改的资源, 缓存在服务器, 缓存有效期内不会在向服务器发起请求, 完成了基本的访问优化

### 再进一步, 我们希望浏览器尽可能的使用缓存, 但是由服务器决定当前请求是否可以使用缓存资源 -> 协商缓存

Last-Modifed / If-Modifed-Since
首次访问服务器后, 服务器会向浏览器发送 Last-Modifed 头, 下次再请求时, 会把其值作为 If-Modifed-Since 的值发到服务器, 用于判断是否可用缓存
若可以使用, 则直接使用浏览器缓存, 会发起请求, 但是直接 304,

### 再进一步, 对资源进行多次修改后, 若果文件内容发生变话又变回最初状态, 此时 last-modifed 会更新, 但是实际上文件内容没有发生变化, 如果针对这种情况做优化 -> etag

不同的静态服务器生成 last-modifed 和 etag 的规则有微小差别

etag 会对比文件内容, 比较结果精准, 但是对于较大的文件, 会有性能问题, 这种情况下, 不会全量对比文件, 可能会对比某几行或文件大小或文件开头的部分, 或者采取下面说到的摘要算法

crypto
摘要算法, 加密算法

md5 属于摘要算法, 因为加密算法的基本要求是可以加密/解密, 但 md5 加密过程是不可逆的
md5 的特点:

1. 不可逆
2. 相同内容的摘要结果是相同的
3. 不同内容的摘要长度是相同的
4. 只要摘要不同, 内容绝对不同

但是普通级别的 md5 摘要信息可能会通过'撞库'进行破解, 这是可以对结果值进行多次 md5 操作, 或者使用进阶版加密方式

改进型 -> 加盐算法: node 自带的 sha256
选择一串秘钥, 和内容一起进行加密, 对于相同的内容, 若使用相同的盐, 则摘要信息相同

### 对服务器资源进行优化的核心原则: 响应不携带资源,尽可能使用缓存; 一定要携带时, 对携带的内容进行压缩

zlib
适用于重复度高的内容

浏览器发出请求时, 会在 Header 中携带 Accept-Encoding 头, 用来告知服务器其支持的压缩类型(因为要对服务器的响应进行解压)
常用的压缩类型有 Accept-Encoding: gzip, deflate

若要使用压缩, 则服务器对资源进行压缩后, 还必要设置响应头 Content-Encoding, 负责浏览器可能无法解压(乱码)或者会错误解读响应类型, 进行错误动作(如错当为下载)

注意: 在 req 中读取 header 全都是小写开头, 设置 res header 全都是大写开头, 两者均 大小写敏感

### 浏览器/服务器 交互

req, res 都是流

req 接收发送端数据时, 也会依据流的形式进行读取 req.on('data', thunk => {}), 读取完毕后, 把读取到的所有 thunk(Buffer) 进行拼接

CORS
注意 同源策略只针对 Ajax 请求, 使用表单提交等方法不会受到此影响

1. 由于浏览器的同源策略, 出现跨域问题时, 常用解决方式是通过后端配置对应的 http 头, 具体在使用时查询; 跨域发生时, 服务器实际是可以收到此请求的
   允许访问的域 -> Access-Control-Allow-Origin: '.., ..'

2. 非简单请求, 会在真正发起请求前, 发送 option 预请求, option 伴随着跨域产生, 一般还需要在后端处理 option 请求

3. 那什么时候会认定一个请求是 '非简单请求' 呢? 有一种情况就是请求头中含有自定义 header, 此时后端还需要明确在响应头中设置允许此自定义头才行
   允许的 Header -> Access-Control-Allow-Headers: 'Content-Type, ...'

4. 此时基本的 简单/非简单请求 的跨域问题应该都已经解决, 但是每次发送非简单请求时, 都会先发送一个 option 请求, 可以设置一个事件限制 option 的发起频率
   option 发起频率 -> Access-Control-Max-Age: 10

5. 默认跨域只能识别 GET, POST 请求, 若有其他诸如 DELETE, PUT 请求时, 也会报错, 这里可以设置一个响应头来处理
   允许的方法 -> Access-Control-Allow-Method: 'POST, DELETE, PUT, ...'

6. 再复杂一些, 当请求携带 cookie 时, 也会报错, 这时又可以配置另一个响应头来处理, 并且注意一旦设置此头, Access-Control-Allow-Origin 的值就不能是 \*
   允许的 cookie -> Access-Control-Allow-Credentials: true

FORM
在使用表单上传时, 除了可以上传基本的简单数据类型, 还可以用来上传文件, 需要设置 content-type 为 'multipart/form-data'
在请求发出后, 浏览器会自动在每个字段间加入 boundary 分隔符, 最原始的处理方式需要把传到服务器的二进制流以 boundary 进行分割, 找到每个 form item

除了原生表单还可以在 Ajax 中通过 new FormData() 来模拟表单行为, 两种方式在到达服务器时, 表现行为是一样的

---

### 面试逐字稿 - 浏览器缓存策略

- 在整个网络请求链路中，可能会存在 dns 缓存，http 缓存，cdn 缓存 等等

- 在浏览器层面的缓存，一般有 http 缓存

- 通过一些 http 头的设置，可以分为 **强缓存**，**协商缓存** 两种实现

- 强缓存的实现，主要是通过服务端响应设置 cache-control:max-age=(xxx/单位:秒) 来实现，max-age 规定了资源的有效期
  如果强缓存命中，会直接使用本地缓存资源，不进行网络请求

- 协商缓存的实现可以分为两种维度

  一种是以资源更新时间为依据，服务器可以设置 last-modifiy 请求头，下次请求时，浏览器会在请求头中携带 if-modified-since 头，值为 last-modifiy 的值，服务器通过判断两个时间决定是否使用缓存

  一种是以资源内容摘要为依据，服务器通过设置 etag 请求头，下次请求时，浏览器会在请求头中携带 if-none-match 头，值为 etag 的值，服务器通过判断两个 hash 决定是否使用缓存

  与强缓存的最大区别是，他一定会发起一次网络请求
  但如果缓存命中，则响应状态码 304，且不携带请求体，并直接使用本地缓存资源；
  否则会携带最新的资源，并更新 last-modify/etag 响应头信息

- 浏览器在进行缓存判断时，会先进行强缓存判断，不匹配才会进行协商缓存的判断

- `cache-control` 头还有一些其他的值可供选择，如：
  public，任何对象或代理都可以缓存此资源
  private，只能被单个用户缓存，不能被代理服务器缓存
  no-cache，会缓存资源，但使用前一定要发起请求，和服务器协商
  must-revalidate，如果资源没有过期，就是用，如果过期了则发起协商验证请求
  no-store，不进行缓存

- 一般生产中，直接设置 SPA 入口为 no-store，并且在打包产物是使用 hash 文件名，并且给这些 js，css 资源一个超长强缓存时间
  因为 SPA 入口本身比较小，网络请求花销不大，且每此最新的 index.html 都会请求最新的 js，css
  这样可以保证我们在更新应用后，始终拿到最新的资源，并且对于请求过的资源不会重复请求

- 另外还有一些比较新的缓存技术，如
  serviceWorker，
