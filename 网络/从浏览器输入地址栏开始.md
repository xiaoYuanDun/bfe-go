### 找浏览器换缓存，有两种情况：

- 找到缓存：
  判断缓存类型：通过 cache-control 判断
  强制缓存：只要 max-age 没有过期，expire（绝对时间）优先级较低, 直接使用本地缓存，状态码 200，服务端实际上没有请求
  协商缓存：当 max-age 过期，就会查看上次请求的 if-modified-since / if-no-match, 若存在就把他们的值放在新的请求头
  last-modified / etag 中，和服务器的 if-modified-since / if-no-match 对比
  可用：就返回 304，响应不携带数据，直接使用本地缓存
  不可用：就当成一个普通请求处理
  - 没找到缓存：
    1. DNS 解析，访问本地配置的 DNS 服务器，首先查找 DNS 缓存，若没找到，DNS 服务器继续访问 DNS 根服务器，从一级域名开始解析，返回较大范围集合给 DNS 服务，然后 DNS 服务器继续解析二级域名，三级域名...，直到找到对应的 IP 地址或报错，若找到 IP 地址，则缓存此对应关系至 DNS 服务器
    2. ARP 协议开始，写入源 IP，源 MAC，目标 IP，需要找到目标 MAC，首先进行本网段的广播，
       如果找到目标，则表示目标设备和源设备在同一个网段，此时目标设备可以得到源设备的 IP 和 MAC，源设备同时收到了目标 IP 和 MAC，双方可 以进行双向缓存
       如果没找到目标，表示目标设备和源设备不在同一网段，此时由本网段网关转发此广播至其他局域网，同时记录此中转设备 MAC 地址，在下一个局域网中继续进行同样操作，直到找到目标设备；当这条链路找到后，从源设备发出的请求中记录的目标 MAC 不是目标设备的 MAC 地址，而是与他最近的中转设备的 MAC 地址
    3. 此时 IP 和 MAC 都已经准备好了，一条 IP 链路已经准备就绪，再此基础上开始 TCP 握手
       客户端发起第一次 tcp 请求，携带 SYN 标志位，表示开始建立连接，seq 标志位，值为一个随机序列 x
       服务端收到请求后，生产响应，携带标志位 ACK=x+1，表示这是处理第一次请求的相应，同时携带 SYN 标志位，seq 标志位，值也是随机序列 y
       客户端收到 ACK = x + 1，就可以得知这是正确响应第一次请求的返回结果，这时客户端又发起第三次请求，携带标志位 ACK = y + 1，表示这是处理响应的请求
       服务端收到 ACK = Y + 1，就可以得知这是转增却响应返回值的第三次请求，这时 tcp 连接建立成功
    4. 这时 tcp/ip 连接已建立成功，http 请求可以再此基础上进行发送，但是一个 tcp 管道中，一次只能处理一个 http 请求，多个 http 请求是串行的（队头阻塞）
    5. 一个 http 请求在 tcp 管道中，会被拆成多个数据段，此时会启用滑动窗口算法（窗口缓冲区大小会在 tcp 交互中动态协商变化的）
       首先以慢启动算法为基础发送数据段，然后等待响应，如果返回值中接收方缓冲区还有富余，则把已正确接收的数据段移除窗口，窗口继续后移，偏移量就是已正确接收到的数据段数量
       在慢启动阶段，会维护一个拥塞窗口变量 cwmd，用来表示单位时间内同时发送的数据段的数量大小，swmd 会指数级增长，直到达到预设阈值 ssthresh，此时启动拥塞避免算法，cwmd 会平稳增长，接下来有两种可能：
       全部发送成功
       出现异常：
       超时：多个请求在超过 RTT 的时间之后依然没有得到响应，断定为网络拥堵，这是把 ssthresh 的值设为出现拥堵时 cwmd 值的一半，并且把 cwmd 设为 1，重新开始一轮慢启动过程
       丢包：当个别包发出后没有响应，而他前后数据包正常响应，此时，他之后的数据包的响应中会携带询问信息，表示服务端没有接收到这个丢失的包，这种询问信息连续出现三次，表示此包丢失，但是他的相邻包可以正确接收，表示网络环境良好，丢包可能是其他原因造成的，这时发送端会重发此包，并且把 ssthresh 的值降为 cwmd 的一半，并且 cwmd 的值不会降为 1，而是此刻 cwmd 的一半，然后直接启动拥塞避免算法（这就是快重转，快恢复）
    6. 服务器正常返回响应, 浏览器缓存这次请求

### 从浏览器的角度看，有以下几步主要流程：

- 首先浏览器是多模块，多进程架构的，当需要发送一个请求时 1. 首先由浏览器主进程通知网络进程发送一个请求，经过上面所说的一系列网络流程后，网络进程收到响应，若需要重定向，则重复一次上述过程，然后通知浏览器主进程准备渲染 2. 主进程收到渲染准备消息后，会向渲染进程发出一个'文档提交'请求，表示网络进程已得到响应内容 3. 当渲染进程收到消息后，会建立一个和网络进程的通道，开始读取响应内容，解析文本，构建布局，渲染页面，一切渲染工作完成后，渲染进程会向主进程发送一个'确认文档提交'请求，表示新的页面已准备好 4. 主进程收到确认消息后，会更新浏览器状态，loading 效果，路由历史等，更新 web 页面

  - 渲染进程的主要工作，这里我们把响应看成一个普通 html 页面来解释
    1. 解析 html 文档，通过 html 解析器，生成对用的 dom
    2. 通过 css 样式表计算样式，给每个 dom 节点添加对应的样式
    3. 通过 dom 和计算之后的 css，计算布局，剔除一些不可见元素，得到布局树
    4. 分层，生成图层树，重排，重绘，合成等操作得到最终的页面

- TODO 是否只访问一次 DNS 根服务器，DNS 缓存在哪里

- TODO ARP 协议多网段时，MAC 地址的情况

- 队头阻塞怎么解决
  因为协议本身的原因，一个 tcp 通道中，同一时间，只能有一个 http 请求，必须要等上一个 http 得到响应，才能发送下一个，http 在 tcp 通道里是串行的
  http1.1 通过开辟多条 tcp 连接通道（同一域名下，最多可同时维持 6 个 tcp 连接），在物理层面上解决 http 的并发问题，但此解决方案效果并不理想，因为：
  在服务器端，请求依然是排队处理
  维持多条 tcp 连接会造成浏览器和服务器额外的资源消耗，在协调资源时，还会出现抢夺网络带宽的竞争状态，导致每个 tcp 连接的网络利用率都很低
  http2 通过在应用层和传输层中间加入新的 '二进制分帧层'，使原来的通信模型从 应用层-传输层 变成 应用层-二进制分帧层-传输层，在 tcp 通道中流动的是经过处理的二进制帧而非原来的数据段，从而突破了一个 tcp 同一时间只能有一个 http 请求的限制，一个 http 会生成一个双向传输流，会分配一个唯一的流 ID，此请求被解析的帧都属于这个流，这就保证了无序的数据帧在服务器会被正确的重新组装起来，但是这种方案依然没有完全解决'队头阻塞'的问题，因为
  http2 虽然有很多新特性用来优化传输，但是他还是建立在 tcp 协议的基础上，因为 tcp 协议本身的工作原理，导致了 tcp 传输出现丢包时，依然会存在类似队头阻塞的问题，如传输 1，2，3 这三个数据段，但是如果服务器只收到 1，3，那么服务器会把已经收到的 1，3 放在缓存区，一直等待 2 的到来，在这之前，1，2，3 都不能被服务器使用
  http3 放弃了 tcp 协议，使用了新的 QUIC 协议，底层网络层使用了 UDP 协议，从而避免了因为 tcp 协议本身的工作流程造成的 '队头阻塞' 问题，但是
  http3 目前还处于开发阶段，而且大规模换装的难度极大（底层协议发生变化）

- https 加密

  1. 客户端会在 TCP 开始连接之前，首先发送自己接受的 TLS 版本和可以加密的密码套件列表 + clientRandom 到服务端
  2. 然后服务端会根据客户端发送过来的版本号和加密套件列表进行选择，会将使用到的加密套件 + 公钥发给 + serviceRandom 发给客户端。
  3. 客户端通过 clientRandom + serviceRandom 生成 pre-master，然后再用公钥加密，发送给服务端
  4. 服务端使用私钥解密出 pre-master，然后双方通过 各自的 clientRandom + serviceRandom + pre-master 生成一个对称秘钥 master-secret。
  5. 客户端通过 master-secret 在发送数据前进行加密，而服务端则用 master-secret 在收到数据后进行解密

- https 数字认证

  1. 虽然可以进行加密解密，但是当黑客进行 DNS 劫持时，将服务端的 ip 换成了自己的 ip，并且冒充成服务端之后，也可以进行该加密解密过程，所以就需要一个权威机构对服务端的网站进行验证。
  2. 当服务端完成了验证，服务端第一次发送公钥的时候会变成发送数字证书
  3. 客户端在拿到数字证书后，会对明文部分进行 hash 函数来计算得到信息 A，然后再利用 CA 的公钥解密签名数据，得到信息 B，对比信息 A 和信息 B，如果 A=B，则证明证书是合法的
  4. 证书合法之后，还需要验证 CA，浏览器寻找 CA 会一直往上找给颁发 CA 的 CA，一直找到顶级的 CA，一般来说，操作系统中会内置信任的顶级 CA，如果找到的顶级 CA 和浏览器中的顶级 CA 不同，也会被判为非法

- TOOD html 解析器的工作原理
  类似 AST 分词，先把 html 文档分成很多个小节点，如：<div>hi</div> 被分解为 [node_div.start, node_content, node_div.end], 解析时使用 栈 的数据结构, 首先会将一个最外层 document 文档节点入栈，接下来遇到 .start 类型节点就入栈，遇到 content 类型就把内容追加在当前栈顶元素内，遇到 .end 类型，就判断当前栈顶元素是否为与之对应的 .start 类型节点，若是，就弹出此节点，并把节点内容追加在当前栈顶元素中，一直执行这个逻辑，知道所以内容解析完毕

- TODO 重拍，重绘，合成的过程

- 有哪些地方可以优化渲染速度

- 有什么东西会阻塞渲染

- 为什么动画在渲染时性能会更好

- 垃圾回收过程

- 网络攻击，XSS, CSRF，
