找浏览器换缓存，有两种情况：
  找到缓存：
    判断缓存类型：通过 cache-control 判断
			强制缓存：只要 max-age 没有过期，expire（绝对时间）优先级较低, 直接使用本地缓存，状态码304，服务端实际上没有请求
			协商缓存：max-age 过期，last-modified/if-modified-since, etag/if-no-match
				可用：就返回304，响应不携带数据，直接使用本地缓存
				不可用：就当成一个普通请求处理
    没找到缓存：
			1. DNS解析，访问本地配置的DNS服务器，DNS服务器继续访问DNS根服务器，从一级域名开始解析，返回较大范围集合给DNS服务，然后DNS服务器继续解析二级域名，三级域名...，直到找到对应的 IP 地址或报		 错，若找到IP地址，则缓存此对应关系
			2. ARP协议开始，写到源IP，源MAC，目标IP，需要找到目标MAC，首先进行本网段的广播，
				 如果找到目标，则表示目标设备和源设备在同一个网段，此时目标设备可以得到源设备的 IP 和 MAC，源设备同时收到了目标 IP 和 MAC，双方可以进行双向缓存
				 如果没找到目标，表示目标设备和源设备不在同一网段，此时由本网段网关转发此广播至其他局域网，同时记录此中转设备 MAC 地址，在下一个局域网中继续进行同样操作，知道找到目标设备；此时，从源设备发出的请求中记录的目标 MAC 不是目标设备的 MAC 地址，而是与他最近的中转设备的 MAC 地址
			3. 此时 IP 和 MAC 都已经准备好了，一条 IP 链路已经准备就绪，再此基础上开始 TCP 握手
				   客户端发起第一次 tcp 请求，携带 SYN 标志位，seq标志位，值为一个随机序列 x，表示开始建立连接
					 服务端收到请求后，生产响应，携带标志位 ACK=x+1，表示这是处理第一次请求的相应，同时携带 SYN 标志位，seq标志位，值也是随机序列 y
					 客户端收到 ACK = x + 1，就可以得知这是正确响应第一次请求的返回结果，这是 客户端又发起第三次请求，携带标志位 ACK = y + 1，表示这是处理响应的请求
					 服务端收到 ACK = Y + 1，就可以得知这是转增却响应返回值的第三次请求，这是 tcp 连接建立成功
			4. 这时 tcp/ip 连接已建立成功，http请求可以再此基础上进行发送，但是一个 tcp 管道中，一次只能处理一个 http 请求，多个 http 请求是串行的（队头阻塞）
			5. 一个 http 请求在 tcp 管道中，会被拆成多个数据段，此时会启用滑动窗口算法（窗口缓冲区大小会在tcp交互中协商决定的）
					 首先以慢启动算法为基础发送数据段，然后等待响应，如果返回值中接收方缓冲区还有富余，则把已正确接收的数据段移除窗口，窗口继续后移，偏移量就是已正确接收到的数据段数量
					 在慢启动阶段，会维护一个拥塞窗口变量 cwmd，用来表示单位时间内同时发送的数据段的数量大小，swmd会指数级增长，直到达到预设阈值 ssthresh，此时启动拥塞避免算法，cwmd会平稳增长，接下来有两种可能：
					 	 全部发送成功
						 出现异常：
						   超时：多个请求在超过 RTT 的时间之后依然没有得到响应，断定为网络拥堵，这是把 ssthresh 的值设为出现拥堵时 cwmd 值的一半，并且把 cwmd 设为一，重新开始一轮慢启动过程
							 丢包：当个别包发出后没有响应，而他前后数据包正常响应，此时，他之后的数据包的响应中会携带询问信息，表示服务端没有接收到这个丢失的包，这种询问信息连续出现三次，表示此包丢失，但是他 的相邻包可以正确接收，表示网络环境良好，丢包可能是其他原因曹成的，这是发送端会重发此包，并且把 ssthresh 的值降为 cwmd 的一半，并且 cwmd 的值不会降为1，而是此刻 cwmd 的一半，然后直接启动拥塞避免算法（这就是快重转，快恢复）
 



z


1. 强制缓存状态码
2. 是否只访问一次DNS根服务器，DNS缓存在哪里
3. ARP 协议多网段时，MAC 地址的情况
4. 队头阻塞怎么解决