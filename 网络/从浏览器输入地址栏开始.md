### 找浏览器换缓存，有两种情况：
  - 找到缓存：
    	判断缓存类型：通过 cache-control 判断
				强制缓存：只要 max-age 没有过期，expire（绝对时间）优先级较低, 直接使用本地缓存，状态码200，服务端实际上没有请求
				协商缓存：当 max-age 过期，就会查看上次请求的 if-modified-since / if-no-match, 若存在就把他们的值放在新的请求头 
						last-modified / etag 中，和服务器的 if-modified-since / if-no-match 对比
					可用：就返回304，响应不携带数据，直接使用本地缓存
					不可用：就当成一个普通请求处理
	- 没找到缓存：
		1. DNS解析，访问本地配置的DNS服务器，首先查找 DNS 缓存，若没找到，DNS服务器继续访问DNS根服务器，从一级域名开始解析，返回较大范围集合给DNS服务，然后DNS服务器继续解析二级域名，三级域名...，直到找到对应的 IP 地址或报错，若找到IP地址，则缓存此对应关系至 DNS 服务器
		2. ARP协议开始，写入源IP，源MAC，目标IP，需要找到目标MAC，首先进行本网段的广播，
				如果找到目标，则表示目标设备和源设备在同一个网段，此时目标设备可以得到源设备的 IP 和 MAC，源设备同时收到了目标 IP 和 MAC，双方可 以进行双向缓存
				如果没找到目标，表示目标设备和源设备不在同一网段，此时由本网段网关转发此广播至其他局域网，同时记录此中转设备 MAC 地址，在下一个局域网中继续进行同样操作，直到找到目标设备；当这条链路找到后，从源设备发出的请求中记录的目标 MAC 不是目标设备的 MAC 地址，而是与他最近的中转设备的 MAC 地址
		3. 此时 IP 和 MAC 都已经准备好了，一条 IP 链路已经准备就绪，再此基础上开始 TCP 握手
				客户端发起第一次 tcp 请求，携带 SYN 标志位，表示开始建立连接，seq标志位，值为一个随机序列 x
				服务端收到请求后，生产响应，携带标志位 ACK=x+1，表示这是处理第一次请求的相应，同时携带 SYN 标志位，seq标志位，值也是随机序列 y
				客户端收到 ACK = x + 1，就可以得知这是正确响应第一次请求的返回结果，这时客户端又发起第三次请求，携带标志位 ACK = y + 1，表示这是处理响应的请求
				服务端收到 ACK = Y + 1，就可以得知这是转增却响应返回值的第三次请求，这时 tcp 连接建立成功
		4. 这时 tcp/ip 连接已建立成功，http请求可以再此基础上进行发送，但是一个 tcp 管道中，一次只能处理一个 http 请求，多个 http 请求是串行的（队头阻塞）
		5. 一个 http 请求在 tcp 管道中，会被拆成多个数据段，此时会启用滑动窗口算法（窗口缓冲区大小会在tcp交互中动态协商变化的）
				首先以慢启动算法为基础发送数据段，然后等待响应，如果返回值中接收方缓冲区还有富余，则把已正确接收的数据段移除窗口，窗口继续后移，偏移量就是已正确接收到的数据段数量
				在慢启动阶段，会维护一个拥塞窗口变量 cwmd，用来表示单位时间内同时发送的数据段的数量大小，swmd会指数级增长，直到达到预设阈值 ssthresh，此时启动拥塞避免算法，cwmd会平稳增长，接下来有两种可能：
				全部发送成功
				出现异常：
					超时：多个请求在超过 RTT 的时间之后依然没有得到响应，断定为网络拥堵，这是把 ssthresh 的值设为出现拥堵时 cwmd 值的一半，并且把 cwmd 设为 1，重新开始一轮慢启动过程
					丢包：当个别包发出后没有响应，而他前后数据包正常响应，此时，他之后的数据包的响应中会携带询问信息，表示服务端没有接收到这个丢失的包，这种询问信息连续出现三次，表示此包丢失，但是他的相邻包可以正确接收，表示网络环境良好，丢包可能是其他原因造成的，这时发送端会重发此包，并且把 ssthresh 的值降为 cwmd 的一半，并且 cwmd 的值不会降为1，而是此刻 cwmd 的一半，然后直接启动拥塞避免算法（这就是快重转，快恢复）
		6. 服务器正常返回响应, 浏览器缓存这次请求
### 从浏览器的角度看，有以下几步主要流程：
  - 首先浏览器是多模块，多进程架构的，当需要发送一个请求时
		1. 首先由浏览器主进程通知网络进程发送一个请求，经过上面所说的一系列网络流程后，网络进程收到响应，若需要重定向，则重复一次上述过程，然后通知浏览器主进程准备渲染 	
		2. 主进程收到渲染准备消息后，会向渲染进程发出一个'文档提交'请求，表示网络进程已得到响应内容
		3. 当渲染进程收到消息后，会建立一个和网络进程的通道，开始读取响应内容，解析文本，构建布局，渲染页面，一切渲染工作完成后，渲染进程会向主进程发送一个'确认文档提交'请求，表示新的页面已准备好
		4. 主进程收到确认消息后，会更新浏览器状态，loading效果，路由历史等，更新 web 页面

	- 渲染进程的主要工作，这里我们把响应看成一个普通 html 页面来解释
		1. 解析 html 文档，通过 html 解析器，生成对用的 dom
		2. 通过 css 样式表计算样式，给每个 dom 节点添加对应的样式
		3. 通过 dom 和计算之后的 css，计算布局，剔除一些不可见元素，得到布局树
		4. 分层，生成图层树，重排，重绘，合成等操作得到最终的页面






- 强制缓存状态码
- 是否只访问一次DNS根服务器，DNS缓存在哪里
- ARP 协议多网段时，MAC 地址的情况
- 队头阻塞怎么解决
- https 加密
- html 解析器的工作原理
- 重拍，重绘，合成的过程
- 有哪些地方可以优化渲染速度
- 有什么东西会阻塞渲染
- 为什么动画在渲染时性能会更好
- 垃圾回收过程
- 网络攻击，XSS, CSRF，
