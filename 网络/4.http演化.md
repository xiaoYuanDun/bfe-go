### http

一条 tcp 通路上, 同一时间只能用有一个 http 请求, 下一个请求必须等上一个得到相应, 才能发送(队头阻塞)

解决并发的方案: 物理层面增加多个 tcp 连接, 但效果一般

### http2

- 在兼容上层 http1 的情况下，加入了 **头部压缩 HPACK 算法** 和 **流** 的功能，形成了 **二进制分帧层** 的概念，同时市面上大部分 http2 都是用 https 协议名，也就是说 http2 都跑在 TLS 上， 正式发送数据前需要进行 tcp 握手, tls 握手

- 由于向上兼容 http1，所以上层的报文内容还是普通的 http 头部 + http 报文 的形式，但是往下，**二进制分帧层** 会进行头部压缩，并把一个 http 请求分解成一个个 **二进制 帧**，这些被拆分的帧会乱序的发往通信对方，从同一个请求拆分出的帧会被标识一个唯一 ID，而通过这个唯一 ID 可以从信道的帧中，选择出从属于同一个请求的所有帧，这样我们就可以在收发双发标识出一个唯一的 **流**，可以理解为，这个请求的所有帧都在这个专用流中进行传输（实际上 **流** 是个逻辑联系，并不真实存在）

- 注意，在 tcp 连接的层面上看，所有帧是乱序发送的，但是，通过一个流 ID 标识出来的属于一个请求的帧，他们是有严格的先后顺序的，因为下层的 tcp 协议会保证这些帧被有序的送达，所以在接收方组装帧时，**拥有相同流 ID 的帧是有序的**，可以看如下解释：

```js
// 拆分：
// stream_1: 1_1, 1_2, 1_3;
// stream_2: 2_1, 2_2;
// stream_3: 3_1, 3_2;

// 这里看是乱序的
// tcp通路: 2_1, 1_1, 2_2, 3_1, 3_2, 1_2, 1_3;

// 组装：
// form stream_1: (2)1_1, (6)1_2, (7)1_3
// form stream_2: (1)2_1, (3)2_2
// form stream_2: (4)3_1, (5)3_2
```

- 由于突破了传统的 http 请求-响应的模型，所以 http2 中可以同时收发多个请求，发送发把多个请求拆分后，将所有帧经过信道推送给对象，接收方，通过唯一的 **流 ID**，还原出发送方的请求，所以

- 其他特性包括：服务器推送，流优先级控制

#### 参考

- [http2-飞书](https://juejin.cn/post/6844903984524705800)

- [http2-极客](https://time.geekbang.org/column/article/112036)

---

### http3

- http2 基本解决了 http 的队头阻塞问题, 但并不是完全解决, 因为其本身依然是依赖 tcp 协议的, 而 tcp 协议依然会存在 **队头阻塞** 的问题，在丢包率较高时，http2 的性能甚至比 http1 还要差

为了从根本上解决此问题, 推出了 http3, 但受制于协议本身的限制, http3 在传输层使用 UDP 协议替换了 TCP 协议

在 UDP 的基础上, 实现连接管理, 拥塞控制, 流量控制等原本在 tcp 上的特性, 实现可靠传输(UDP 本身不提供可靠服务, 只是尽力提供)

### QUIC 协议

#### 参考

- [http3-极客](https://time.geekbang.org/column/article/115564)

- [http3-飞书](https://blog.csdn.net/wolfGuiDao/article/details/108729560)
