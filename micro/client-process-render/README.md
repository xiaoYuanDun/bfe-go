### 通过一个进度条的功能，看重排，重绘对渲染性能的影响

#### App1: 最原始最简单的实现方式

通过 js 来控制进度条宽度, 缺点非常明显, 每一帧都需要重新渲染, 如果渲染逻辑中有大运算量计算, 性能消耗极大, 可以在样例的 utils 中使用 calc 方法来模拟这种情况

#### App2

把进度条逻辑运算内容转移到 css 中, 减少复杂度, 同时组件 render 次数大幅减少

但是这个例子也是通过改变 process 元素的宽度来做的, 只是借助动画实现, 所以实际上元素的宽度一直在改变, 会不断触发重排

#### App3

把进度条元素提到一个单独的图层, 此图层的任何操作变化不会影响到其他图层
这里利用了浏览器的 GPU 加速

通过 f12 performance 工具, 可以看到 paint 和 layout 大幅减少, FPS 非常稳定, 各项数据都是三个例子中最好的

这里就不上截图了, 可以直接用这个项目中的 App1, App2, App3 进行调试, 差别非常明显

#### 几个知识点

- 想重新开始一个动画, 给相应元素一个 相同的动画, 不同的名字 的 keyframe 即可

- 一般的页面渲染有哪些流程, 执行顺序是?

  js --> style --> layout --> paint --> composite

  做页面性能优化时, 在非脚本方向上, 原则是尽量减少 layout 和 paint 的次数

- 重排是什么, 什么操作会引起重排

  浏览器需要重新计算元素的几何属性，而且其他元素的几何属性或位置可能也会因此改变受到影响

  添加或删除可见的 DOM 元素、改变元素位置、元素的尺寸改变（包括：外边距、内边距、边框、高度等）、内容改变（如：文本改变或图片被另外一个不同尺寸的图片替代）、浏览器窗口尺寸的改变、通过 display: none 隐藏⼀个 DOM 节点等

- 重绘是什么, 什么操作会引起重绘

  不是所有的 DOM 变化都影响元素的几何属性，如果改变元素的背景色并不影响它的宽度和高度，这种情况，只会发生一次重绘，而不会发生重排，因为元素的布局没改变

  重排一定会引发重绘, 通过 visibility: hidden 隐藏⼀个 DOM 节点、修改元素背景色、修改字体颜色等

- **TODO** 发现一个现象, 通过 transform 生成单图图层时, 当 translate 小于 9px 时, 可能不会创建新的图层
