### 位运算

调度器实现
react-reconclier

executionContext 用来标识当前处于 React 的哪个执行上下文环境

在 unbatchedUpdates 方法中会切换上下文, 做法就是先保存当前的上下文环境值, 然后修改上下文环境, 在被修改的上下文环境中执行回调, 执行完后再回复为刚才保存的旧上下文环境，react 是通过位操作来切换的

```js
// 这是 18.x 之前的
export const NoContext = /*             */ 0b000000;
const BatchedContext = /*               */ 0b000001;
const EventContext = /*                 */ 0b000010;
const LegacyUnbatchedContext = /*       */ 0b000100;
const RenderContext = /*                */ 0b001000;
const CommitContext = /*                */ 0b010000;
export const RetryAfterError = /*       */ 0b100000;

// 目前最新的上下文状态
const NoContext = /*                    */ 0b000;
const BatchedContext = /*               */ 0b001;
const RenderContext = /*                */ 0b010;
const CommitContext = /*                */ 0b100;
```

- 当进入某个上下文时，可以使用按位或操作标记进入：

```js
// 当前所处上下文
let curContext = 0;

// 进入A上下文
curContext |= A;
```

- 可以结合按位与操作与 NoContext 来判断是否处在某一上下文中：

```js
// 是否处在A上下文中 true
// (curContext & A) !== NoContext

// 是否处在B上下文中 false
// (curContext & B) === NoContext
```

- 离开某上下文后，结合按位与、按位非移除标记：(按位于可以把 cur 和 A 中相同的数位都保留下来, 但是 A 取反后, 本来应该保留下来的数位全都被移除)

```js
// 从当前上下文中移除上下文A
curContext &= ~A;

// 假设 A = 1000
// 当前 上下文 cur = 1010
// A & cur = 1010, ~A = 0111, cur & ~A = 0010
```

### ReactDOM.render 如何被调度

- 在非合成模式下进行更新，更新逻辑和 setState 时类似，都是创建 update，绑定到对应 fiber，然后调度更新

```js
// 更新一下，18.x 之后，unbatchedUpdates 方法已经没有了，我已知的此方法被调用的地方，都已经被 flushSync 代替了
unbatchedUpdates(function () {  // 所以这里应该是 flushSync
  updateContainer(children, fiberRoot, parentComponent, callback);
});
```

- 这里可以看到，整个更新都处于 `unbatched` 环境下，可以详细看 `updateContainer` 中的实现

```js
// ...
var update = createUpdate(eventTime, lane); // 创建 update

update.payload = { element: element };
callback = callback === undefined ? null : callback;

enqueueUpdate(current$1, update); // 绑定 fiber
var root = scheduleUpdateOnFiber(current$1, lane, eventTime); // 执行调度
```

- 这里还有一个点要说明一下，源码里，`unbatchedUpdates` 上下文环境中，scheduleUpdateOnFiber 会直接同步执行更新任务，而不是异步调度，一起看一下这部分逻辑：

```js
// ...
if (lane === SyncLane) {
  if (
    // Check if we're inside unbatchedUpdates
    // unbatchedUpdates 会把 executionContext 变为 LegacyUnbatchedContext，还记得吗
    (executionContext & LegacyUnbatchedContext) !== NoContext &&
    // Check if we're not already rendering
    (executionContext & (RenderContext | CommitContext)) === NoContext
  ) {
    // This is a legacy edge case. The initial mount of a ReactDOM.render-ed
    // root inside of batchedUpdates should be synchronous, but layout updates
    // should be deferred until the end of the batch.
    performSyncWorkOnRoot(root);
  } else {
    ensureRootIsScheduled(root, eventTime);
    if (
      executionContext === NoContext &&
      (fiber.mode & ConcurrentMode) === NoMode
    ) {
      // Flush the synchronous work now, unless we're already working or inside
      // a batch. This is intentionally inside scheduleUpdateOnFiber instead of
      // scheduleCallbackForFiber to preserve the ability to schedule a callback
      // without immediately flushing it. We only do this for user-initiated
      // updates, to preserve historical behavior of legacy mode.
      resetRenderTimer();
      flushSyncCallbacksOnlyInLegacyMode();
    }
  }
} else {
  // Schedule other updates after in case the callback is sync.
  ensureRootIsScheduled(root, eventTime);
}

return root;
// ...
```

- 总结一下 render 的过程：

1. 生成 rootFiberNode
2. 生成 update，绑定 update 到 rootFiber 上
3. 调度更新(同步的，源码中说这是个遗留问题，我暂时也不是很明白为什么)
