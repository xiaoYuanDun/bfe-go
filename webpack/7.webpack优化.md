### 如何做 webpack 优化, 有哪些方法/方向

- 缩小查找范围

1. resolve.extension 后缀优先匹配
2. resolve.alias 别名减少代码量
3. resolve.moduels 优先选择配置的路径
4. resolve.mainFields(优先级更高), resolve.mainFiles 优先查找入口文件
5. rules 匹配规则, 使用 oneOf(匹配到即跳过) 替换单一 test(遍历所有 test)

- 跳过无用的解析

1. module.noParse 忽略指定模块的解析

- 跳过无用的模块/子模块

1. webpack.IgnorePulgin

- 量化打包指标 速度/体积

1. 通过插件实现

- css 优化

1. 压缩 css
2. css 的 tree-shaking, 借助插件

- TODO: 多线程处理

- CDN

- js 优化

1. tree-shaking
   es6 module 才支持
   针对 lodash 的优化可以做，但是效果不明显，因为三方包很有可能全量引用了 lodash，所以单独在代码里做针对 lodash 的优化效果不可控
   有副作用的代码不会被 tree-shaking 掉, 一般是 css, polyfill

2. 压缩 webpack5 mode=production 自带

- 代码分割

1. 通过入口分割, entry 配置多个入口, 每个入口会被拆分为一个 chunk 代码块, 这是 webpack 的默认行为, 但是会全量打包每个入口所需的全部代码, 即使所有入口都包含公共代码, 比如都使用了 lodash, 那么每个包都会打包一个 lodash 的副本

2. import 会被认定为一个代码分割点, 按需动态加载, 可通过插件实现 preload, prefetch 的效果 [官方介绍](https://webpack.docschina.org/guides/code-splitting/#prefetchingpreloading-modules)

3. 手动提取公共代码块 [参考](http://www.javascriptpeixun.cn/course/3197/task/213264/show#)

- 作用域提升(默认自带的)

- webpack 缓存

  babel-loader 自带缓存功能
  webpack5 cache

### TODO

- tree-shaking 原理

- react 中如何实现按需加载
