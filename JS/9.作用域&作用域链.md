### 介绍一下作用域&作用域链

说作用域之前先说一下执行上下文的概念

在运行一段可执行的 js 代码时，都会创建一个对应的执行上下文，并且一个与之关联的变量对象，当前上下文中所有的变量或函数都存在与这个变量对象上

全局上下文时最外层的上下文

js 是通过维护一个栈结构，

每个函数调用都有自己的上下文，当函数代码执行时，函数上下文会被推入执行上下文栈，执行完毕后又会出栈，将控制权交给之前的上下文

通过这种方式，来切换不同的执行上下文，激活和删除不同的变量对象

---

首先说一下作用域

<!-- 可以把它理解为一块在程序中定义变量的区域，他决定了内部变量的生命周期，控制着他们的可访问范围。 -->

可以理解为对一个执行上下文中对应的变量对象的限定，它决定了变量对象中的变量和函数的生命周期，控制着他们的可访问范围

目前主要存在的作用域有两种，全局作用域，函数作用域

块级作用域比较特殊，需要配合 let，const 来创建

---

再说作用域链

它描述了，在一个作用域中，某个变量的查找访问的顺序，如果变量不存在，下一步做什么，去哪里查找，描述了这条链路

作用域链的顺序是由词法作用域来决定的，词法作用域是静态的作用域，只和函数声明的位置有关，与函数调用位置无关

最典型最普遍的作用域链的表现，就是闭包

---

闭包

闭包的本质其实是作用域链的表现：
某些函数因为持有了上一级的词法作用域中的变量，导致了调用栈即使弹出了某个执行上下文，依然不能回收其控制的变量对象，因为作用域链保存了这个变量的寻址路径，这就形成了闭包

### 面试逐字稿 - 介绍一下作用域/作用域链

- 首先说一下执行上下文，在一段可运行的 js 代码执行时，都会创建一个与之对应的执行上下文，并且有一个与上下文关联的变量对象，维护了当前上下文的一些变量属性或者方法

- 然后作用域呢，就可以看成是对一个执行上下文关联连的变量对象的限定，它控制着变量对象中的所有属性的生命周期，决定了这些变量的可访问范围

- 主要的作用域有 全局作用域 和 函数作用域 两种，还有 ES6 新推出的块级作用域

- 然后作用域链，主要描述了，在一个作用域中，某个变量的访问查找的路径。比如，当我们访问的变量不存在于当前作用域时，下一步应该做什么，要去哪里继续查找，他就描述了这条查找链路

- 然后呢，作用域链的顺序是有词法作用域来决定的，而词法作用域是一种静态作用域，也就是说作用域链的产生之和函数声明的位置有关，和函数调用的位置无关

- 一个比较典型的作用域/作用域链的表现形式，就是闭包

- 闭包的本质其实就是作用域链的表现
  某些函数的返回值是一个新的函数，但是因为在新的函数中持有了当前函数作用域中的的一些变量，导致了当前函数执行完毕后，虽然它的的执行上下文已经被弹出了调用栈，但对应的活动对象依然不能被回收。

  因为新函数在声明的过程中就已经构建了和当前函数的作用域链关系，新函数需要保证，当访问到这些变量时，可以通过作用域链找到正确的值，所以当前函数对应的活动对象不能被回收