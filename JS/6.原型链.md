### instanceof

- 先说一下 `instanceof` 是干什么的，官方解释：用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上 [传送门](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/instanceof)

- 最朴素的用法就是判断，一个对象是不是某个构造函数的实例

- 当 `obj instanceof Foo` 返回 true 时，并不代表它永远是 true，因为它的原型链引用时可以更改的

- 还可能用到的方法，[getPrototypeOf](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/GetPrototypeOf), [isPrototypeOf](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/isPrototypeOf)

- instanceof 的左右分别是 **对象** 和 **函数**， isPrototypeOf 操作的是两个对象 `A.isPrototypeOf(a)` 表示 A 是否出现在 a 的原型链上，注意区别

```js
function A() {}

const a = new A();

// A.prototype 是否在 a 的原型链上，下面的两种写法是相同的意义，看到区别了吗
a instanceof A; // true,
A.prototype.isPrototypeOf(a); // true,
```

- instanceof 的核心就是遍历左侧参数的原型链，看是否有满足条件的对象，手写：

```js
const instanceof_ = (obj, constructor) => {
  let objProto = obj.__proto;
  const targetPrototype = constructor.prototype;
  while (1) {
    // 所有原型链已经遍历完
    if (objProto === null) {
      return false;
    }
    if (objProto === targetPrototype) {
      return true;
    }
    objProto = objProto.__proto__;
  }
};
```

---

### 工厂模式

可以批量创建对象，也可以封装相同赋值逻辑等，但是不能解决对象识别问题

### 构造函数

有了构造函数之后，创造对象的方式更简单了，使用 `new` 操作符调用构造函数即可。构造函数的方式和工厂模式所做的工作基本一致，只是有下面一点区别：

- 不用显式的创建对象
- 方法和属性，直接通过 `this` 赋予对象
- 可以没有显式的 return

并且可以通过 `instanceof` 方法，判断对象的类型

### 原型模式

构造函数存在一个问题，就是对于同一个函数，每个对象实例，都会生成一份自己的引用，这其实是没有必要的

### 继承

原型最大的问题是，当原型对象上存在引用类型时，其不同实例通过原型对该引用类型进行的修改，会反应在所有实例中

### 原型链

同样会出现上面提到过的，引用类型共享的问题

### 盗用构造函数

相当于把父构造函数绑定在自己的执行上下文里执行，在自己的实例上创建了一个独立的父属性
盗用构造函数模式，其实就是构造函数模式，所以构造函数模式存在的问题，它都存在

### 组合继承

原型链继承 + 盗用构造函数
父构造器会被调用两次，并且会在 "作为子实例的原型对象" 的父实例上，产生不必要的实例属性

### 原型式继承

一个特定场景的继承方式，这种场景不在意是否存在构造函数，只是想构建两个对象之间的信息共享关联关系

### 寄生继承

使用某种可以返回一个新对象的函数，然后在对这个对象进行一些加强，最后返回这个对象
思路类似于：工厂模式 + 构造函数模式
同时，同样具有构造函数模式的缺点，通过加强方式添加的函数，难以重用

### 寄生式组合继承

与寄生继承不同的是，把原本的对 "对象的加强"，变成了对 "对象的原型对象的加强"

### todo

- 继承是如何做到屏蔽原型里的引用类型的不互相影响的

---

### 面试逐字稿 - 介绍一下原型链

- 说到原型链，首先要说一下继承，这是原型/原型链的核心作用

- 在 js 中，想要实现继承，是通过在两个对象之间建立关联来实现的，而不是创建目标对象的副本的方法

- 每个 js 对象在创建时就会和另一个对象通过 `.__proto__` 进行关联，这个被关联的对象就是当前对象的原型对象

- 当我们访问一个 js 实例的属性时，如果它本身不存在这个属性，那么就会查找和他关联的原型对象中是否有这个属性，达到继承的效果

那关于原型链呢，首先原型对象也是一个 js 实例，也可以通过对应的构造函数创建出来，所以他也有自己的原型对象，拿刚才的例子来说，当我们需要查找的属性在他的原型对象中也不存在时，就会继续在原型对象的原型对象中进行查找，这个过程会一直递归的执行下去，直到找到属性或到达原型终点 null。整个这条由 js 对象以及原型对象组成的查询链路就可以看做是原型链

这其中会存在各种各样的指针指向，比如 `.__proto__`, `.prototype`, `.constructor`

原型链是由一级一级的原型引用构成的链表结构

### 如何实现继承

有很多种方法都可以实现继承，大概介绍一下演进的过程

首先是 原型继承，可以通过设置 prototype 建立联系，但是有个问题是，当原型中存在引用型属性时，不同的实例都可以对他进行影响；且在创建子对象时，不能向父构造函数传参

然后是 盗用构造函数，他解决了上面的问题，它再创建自己的实例时，会以自己的执行上下文执行父构造函数，但是这样会导致每个实例都产生了自己的方法，没有很好地复用

接下来就出现了组合集成，是 原型继承 和 盗用构造函数的结合，通过原型继承的方式继承方法，通过盗用构造函数的方式解决引用类型共享，不能向父构造函数传参的问题

但这也不是最完美的，主要是因为 子构造函数是通过一个父构造函数的实例来建立原型连接的，实际上我们并不需要实例化一个父对象，它会调用两次父构造函数

所以又出现了寄生组合继承的方式，主要解决的问题就是不需要初始化一个冗余的父实例来做桥接，而是构建了一个临时对象，通过 Object.create 建立临时对象与父构造函数的原型之间的联系，并通过实例化这个临时对象而不是父构造函数，来规避额外的一次父构造函数调用

这种方式是目前最理想的继承范式
