### instanceof

- 先说一下 `instanceof` 是干什么的，官方解释：用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上 [传送门](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/instanceof)

- 最朴素的用法就是判断，一个对象是不是某个构造函数的实例

- 当 `obj instanceof Foo` 返回 true 时，并不代表它永远是 true，因为它的原型链引用时可以更改的

- 还可能用到的方法，[getPrototypeOf](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/GetPrototypeOf), [isPrototypeOf](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/isPrototypeOf)

- instanceof 的左右分别是 **对象** 和 **函数**， isPrototypeOf 操作的是两个对象 `A.isPrototypeOf(a)` 表示 A 是否出现在 a 的原型链上，注意区别

```js
function A() {}

const a = new A();

// A.prototype 是否在 a 的原型链上，下面的两种写法是相同的意义，看到区别了吗
a instanceof A; // true,
A.prototype.isPrototypeOf(a); // true,
```

- instanceof 的核心就是遍历左侧参数的原型链，看是否有满足条件的对象，手写：

```js
const instanceof_ = (obj, constructor) => {
  let objProto = obj.__proto;
  const targetPrototype = constructor.prototype;
  while (1) {
    // 所有原型链已经遍历完
    if (objProto === null) {
      return false;
    }
    if (objProto === targetPrototype) {
      return true;
    }
    objProto = objProto.__proto__;
  }
};
```

---

### 工厂模式
可以批量创建对象，也可以封装相同赋值逻辑等，但是不能解决对象识别问题

### 构造函数
有了构造函数之后，创造对象的方式更简单了，使用 `new` 操作符调用构造函数即可。构造函数的方式和工厂模式所做的工作基本一致，只是有下面一点区别：
- 不用显式的创建对象
- 方法和属性，直接通过 `this` 赋予对象
- 可以没有显式的 return 

并且可以通过 `instanceof` 方法，判断对象的类型

### 原型模式
构造函数存在一个问题，就是对于同一个函数，每个对象实例，都会生成一份自己的引用，这其实是没有必要的

### 继承
原型最大的问题是，当原型对象上存在引用类型时，其不同实例通过原型对该引用类型进行的修改，会反应在所有实例中

### 原型链
同样会出现上面提到过的，引用类型共享的问题

### 盗用构造函数
相当于把父构造函数绑定在自己的执行上下文里执行，在自己的实例上创建了一个独立的父属性
盗用构造函数模式，其实就是构造函数模式，所以构造函数模式存在的问题，它都存在

### 组合继承
原型链继承 + 盗用构造函数
父构造器会被调用两次，并且会在 "作为子实例的原型对象" 的父实例上，产生不必要的实例属性

### 原型式继承
一个特定场景的继承方式，这种场景不在意是否存在构造函数，只是想构建两个对象之间的信息共享关联关系

### 寄生继承
使用某种可以返回一个新对象的函数，然后在对这个对象进行一些加强，最后返回这个对象
思路类似于：工厂模式 + 构造函数模式
同时，同样具有构造函数模式的缺点，通过加强方式添加的函数，难以重用

### 寄生式组合继承
与寄生继承不同的是，把原本的对 "对象的加强"，变成了对 "对象的原型对象的加强"

### todo
- 继承是如何做到屏蔽原型里的引用类型的不互相影响的